import sqlite3
from threading import Lock
from time import sleep

from abstracts.parsers import Parser
from parsers.config import ConfigurationParser
from utils.timestamp_handler import TimestampHandler

class SlipsParser(Parser):
    name = "Slips"
    tool_name = 'slips'
    # used to lock each call to commit()
    cursor_lock = Lock()

    def init(self,
             slips_db=None):
        # this has to be the path of the sqlite3 db generated by slips
        # with all the labels and AIDs
        self.slips_db: str = slips_db
        # caches the labeled tws
        self.labeled_tws = []
        self.timestamp_handler = TimestampHandler()
        self.read_configuration()
    
    def read_configuration(self):
        config = ConfigurationParser()
        self.version = config.slips_version()
    def connect(self):
        self.conn = sqlite3.connect(self.slips_db, check_same_thread=False)
        self.conn.row_factory = sqlite3.Row

        self.cursor = self.conn.cursor()


    def iterate(self, table: str):
        """
        returns an iterator for all rows in the flows table in slips db
        :param table: table to iterate in slips db
        """
        self.execute(f'SELECT * FROM {table};')

        while True:
            row = self.fetchone()
            if row is None:
                break
            yield dict(row)


    def fetchone(self):
        """
        wrapper for sqlite fetchone to be able to use a lock
        """
        self.cursor_lock.acquire(True)
        res = self.cursor.fetchone()
        self.cursor_lock.release()
        return res

    def execute(self, query, params=None):
        """
        wrapper for sqlite execute()
        To avoid 'Recursive use of cursors not allowed' error
        and to be able to use a Lock()
        since sqlite is terrible with multi-process applications
        this should be used instead of all calls to commit() and execute()
        """

        try:
            self.cursor_lock.acquire(True)

            if not params:
                self.cursor.execute(query)
            else:
                self.cursor.execute(query, params)
            self.conn.commit()

            self.cursor_lock.release()
        except sqlite3.Error as e:
            if "database is locked" in str(e):
                self.cursor_lock.release()
                # Retry after a short delay
                sleep(0.1)
                self.execute(query, params=params)
            else:
                # An error occurred during execution
                print(f"Error executing query ({query}): {e}")


    def print_stats(self):
        self.log('', "-" * 30)
        self.log(f"Total malicious labels: ",
                 self.db.get_flows_count(self.tool_name, 'malicious'))
        self.log(f"Total benign labels: ",
                 self.db.get_flows_count(self.tool_name, 'benign'))
        self.log('', "-" * 30)

        print()
        
        
    def mark_tw_as_malicious(self, timestamp: str, ip: str) -> bool:
        """
        marks the tw of the given ts as malicious by slips in the db
        :param timestamp: timestamp of the start or end of a malicious alert
        :param ip: the source ip that was marked as malicious by slips
        """
        timestamp = float(timestamp)
        ip = ip.replace("profile_","")
        if tw_number := self.db.get_timewindow_of_ts(timestamp):
            self.db.set_tool_label_for_tw(
                ip, self.tool_name, tw_number, 'malicious')
            return True
        return False
    
    def parse_alerts_table(self):
        """
        Handles the labeling of slips timewindows
        by parsing the labels set by slips for each timewindow,
        and marking them as malicious in this tools' db
        """
        for alert in self.iterate('alerts'):
            # what we're doing here is marking tw 1 and 2 as malicious if a
            # slips alert exists in parts of both
            #                1:30                   2:30
            #                 │      slips alert     │
            #                 ├──────────────────────┤
            # 1:00                       2:00                         3:00
            # ├───────────────────────────┼────────────────────────────┤
            # │             tw 1                 tw 2                  │
            for ts in (alert['tw_start'], alert['tw_end']):
                self.mark_tw_as_malicious(ts, alert['ip_alerted'])
    
    
    def parse_flow_by_flow_labels(self):
        """
        parses the labels set by slips flow by flow
        :return:
        """
        flows_count = 0
        for row in self.iterate('flows'):
            row: dict
            flow = {
                'aid': row['aid'],
                'label' : row['label']
            }
            
            if self.db.store_flow(flow, self.tool_name):
                flows_count += 1
                # used for printing the stats in the main.py
                #TODO shouldn't be stored in a separate table!
                self.db.store_flows_count(self.tool_name, flows_count)
    
    def print_number_of_alerts_slips_detected(self):
        """
        prints the number of alerts detected by slips from the alerts
        table
        """
        self.execute("SELECT COUNT(*) FROM alerts")
        alerts_number: int = self.fetchone()[0]
        self.log(
            f"Number of alerts found in Slips alerts table: ",
            alerts_number
            )
        
    def print_number_of_slips_mapped_malicious_timewindows(self):
        """
        prints the number of slips "malicious" timewindows as seen by the gt.
        so this number is the answer to the following questions
        to how many tws were the alerts in slips db mapped?
        :return:
        """
        count: int = self.db.get_timewindow_count_by_label(
            self.tool_name,
            "malicious"
            )
        self.log(f"Slips alerts were mapped to: ",
                 f"{count} GT timewindows")
    def parse(self):
        """
        reads the output db of slips with
        the labels and stores it in this tools' db
        """
        self.log("Using Slips Version: ", self.version)
        self.connect()
        # labeling flows
        self.parse_flow_by_flow_labels()
        self.print_stats()
        # labeling tws
        self.print_number_of_alerts_slips_detected()
        self.parse_alerts_table()
        self.print_number_of_slips_mapped_malicious_timewindows()
