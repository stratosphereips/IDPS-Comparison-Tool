import os
import sqlite3
from abstracts.parsers import Parser
from utils.timestamp_handler import TimestampHandler
from threading import Lock
from time import sleep

class SlipsParser(Parser):
    name = "Slips"
    # used to lock each call to commit()
    cursor_lock = Lock()

    def init(self,
             slips_db=None):
        # this has to be the path of the sqlite3 db generated by slips with all the labels and AIDs
        self.slips_db: str = slips_db
        # caches the labeled tws
        self.labeled_tws = []
        self.timestamp_handler = TimestampHandler()

    def connect(self):
        self.conn = sqlite3.connect(self.slips_db, check_same_thread=False)
        self.conn.row_factory = sqlite3.Row

        self.cursor = self.conn.cursor()


    def iterate(self, table: str):
        """
        returns an iterator for all rows in the flows table in slips db
        :param table: table to iterate in slips db
        """
        self.execute(f'SELECT * FROM {table};')

        while True:
            row = self.fetchone()
            if row is None:
                break
            yield dict(row)


    def fetchone(self):
        """
        wrapper for sqlite fetchone to be able to use a lock
        """
        self.cursor_lock.acquire(True)
        res = self.cursor.fetchone()
        self.cursor_lock.release()
        return res

    def execute(self, query, params=None):
        """
        wrapper for sqlite execute() To avoid 'Recursive use of cursors not allowed' error
        and to be able to use a Lock()
        since sqlite is terrible with multi-process applications
        this should be used instead of all calls to commit() and execute()
        """

        try:
            self.cursor_lock.acquire(True)

            if not params:
                self.cursor.execute(query)
            else:
                self.cursor.execute(query, params)
            self.conn.commit()

            self.cursor_lock.release()
        except sqlite3.Error as e:
            if "database is locked" in str(e):
                self.cursor_lock.release()
                # Retry after a short delay
                sleep(0.1)
                self.execute(query, params=params)
            else:
                # An error occurred during execution
                print(f"Error executing query ({query}): {e}")


    def print_stats(self):
        self.log('', "-" * 30)
        self.log(f"Total malicious labels: ", self.db.get_flows_count('slips', 'malicious'))
        self.log(f"Total benign labels: ", self.db.get_flows_count('slips', 'benign'))
        self.log('', "-" * 30)

        print()
    def parse_alerts_table(self):
        """
        Handles the labeling of slips timewindows
        by parsing the labels set by slips for each timewindow,
        and marking them as malicious in this tools' db
        """
        def mark_tw_as_malicious(ts: str, ip: str):
            """
            marks the tw of the given ts as malicious by slips in the db
            :param ts: timestamp of the start or end of a malicious alert
            :param ip: the source ip that was marked as malicious by slips
            """
            ts = float(ts)
            ip = ip.replace("profile_","")
            if tw_number := self.db.get_timewindow_of_ts(ts):
                self.db.set_tw_label(ip, 'slips', tw_number, 'malicious')
                return True

        for alert in self.iterate('alerts'):
            # what we're doing here is marking tw 1 and 2 as malicious if a slips alert exists in parts of both
            #                      1:30                           2:30
            #                      │          slips alert          │
            #                      ├───────────────────────────────┤
            # 1:00                                 2:00                                  3:00
            # ├────────────────────────────────────┼─────────────────────────────────────┤
            # │             tw 1                   │            tw 2                     │

            for ts in (alert['tw_start'], alert['tw_end']):
                mark_tw_as_malicious(ts , alert['ip_alerted'])


    def parse_flow_by_flow_labels(self):
        """
        parses the labels set by slips flow by flow
        :return:
        """
        flows_count = 0
        for row in self.iterate('flows'):
            # each row is a dict
            flow = {
                'aid': row['aid'],
                'label' : row['label']
            }

            if self.db.store_flow(flow, 'slips'):
                flows_count += 1
                # used for printing the stats in the main.py #TODO shouldn't be stored in a separate table!
                self.db.store_flows_count('slips', flows_count)

        self.print_stats()


    def parse(self):
        """reads the output db of slips with the labels and stores it in this tools' db"""
        # connect to the given db
        self.connect()
        # labeling flows
        self.parse_flow_by_flow_labels()
        # labeling tws
        self.parse_alerts_table()
