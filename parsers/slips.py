import sqlite3
import traceback
import os
from threading import Lock
from time import sleep


from abstracts.parsers import Parser
from parsers.config import ConfigurationParser
from utils.file_handler import validate_path
from utils.timestamp_handler import TimestampHandler

class SlipsParser(Parser):
    name = "SlipsParser"
    tool_name = 'slips'
    # used to lock each call to commit()
    cursor_lock = Lock()

    def init(self, args: list):
        # this has to be the path of the sqlite3 db generated by slips
        # with all the labels and AIDs
        self.slips_db: str = args[0]
        if not validate_path(self.slips_db):
            raise TypeError(f"Invalid Slips DB path {self.slips_db}")
        # caches the labeled tws
        self.labeled_tws = []
        self.timestamp_handler = TimestampHandler()
        self.read_configuration()
    
    def read_configuration(self):
        config = ConfigurationParser()
        self.version = config.slips_version()
        
    def connect(self):
        self.conn = sqlite3.connect(self.slips_db, check_same_thread=False)
        self.conn.row_factory = sqlite3.Row
        self.cursor = self.conn.cursor()

    def iterate(self, table: str):
        """
        returns an iterator for all rows in the flows table in slips db
        :param table: table to iterate in slips db
        """
        self.execute(f'SELECT * FROM {table};')

        while True:
            row = self.fetchone()
            if row is None:
                break
            yield dict(row)


    def fetchone(self):
        """
        wrapper for sqlite fetchone to be able to use a lock
        """
        self.cursor_lock.acquire(True)
        res = self.cursor.fetchone()
        self.cursor_lock.release()
        return res

    def execute(self, query, params=None):
        """
        wrapper for sqlite execute()
        To avoid 'Recursive use of cursors not allowed' error
        and to be able to use a Lock()
        since sqlite is terrible with multi-process applications
        this should be used instead of all calls to commit() and execute()
        """

        try:
            self.cursor_lock.acquire(True)

            if not params:
                self.cursor.execute(query)
            else:
                self.cursor.execute(query, params)
            self.conn.commit()

            self.cursor_lock.release()
        except sqlite3.Error as e:
            if "database is locked" in str(e):
                self.cursor_lock.release()
                # Retry after a short delay
                sleep(0.1)
                self.execute(query, params=params)
            else:
                self.log(f"Error executing query",
                         f"({query}): {e}",
                         error=True)


    def print_stats(self):
        self.log('', "-" * 30)
        self.log(f"Total malicious labels: ",
                 self.db.get_flows_count(self.tool_name, 'malicious'))
        self.log(f"Total benign labels: ",
                 self.db.get_flows_count(self.tool_name, 'benign'))
        self.log('', "-" * 30)

        print()
        
        
    def mark_tw_as_malicious(self, timestamp: str, ip: str) -> bool:
        """
        marks the tw of the given ts as malicious by slips in the db
        :param timestamp: timestamp of the start or end of a malicious alert
        :param ip: the source ip that was marked as malicious by slips
        """
        timestamp = float(timestamp)
        ip = ip.replace("profile_","")
        if tw_number := self.db.get_timewindow_of_ts(timestamp):
            self.db.set_tool_label_for_tw(
                ip, self.tool_name, tw_number, 'malicious')
            return True
        return False
    
    def parse_alerts_table(self):
        """
        Handles the labeling of slips timewindows
        by parsing the labels set by slips for each timewindow,
        and marking them as malicious in this tools' db
        """
        for alert in self.iterate('alerts'):
            # what we're doing here is marking tw 1 and 2 as malicious if a
            # slips alert exists in parts of both
            #                1:30                   2:30
            #                 │      slips alert     │
            #                 ├──────────────────────┤
            # 1:00                       2:00                         3:00
            # ├───────────────────────────┼────────────────────────────┤
            # │             tw 1                 tw 2                  │
            self.mark_tw_as_malicious(alert['tw_start'], alert['ip_alerted'])
            # the goal of this is the following:
            # if slips has an alert from 1:00 to 2:00 then we shouldnt mark
            # the tw starting with 2:00 as malicious
            # but if slips has an alert from 1:00 to 2:30, then we should
            # mark the timewindow that has the 2:30 as malicious
            if not self.db.does_ts_equals_to_start_of_a_tw(alert['tw_end']):
                self.mark_tw_as_malicious(alert['tw_end'], alert['ip_alerted'])


    def parse_flow_by_flow_labels(self):
        """
        parses the labels set by slips flow by flow
        :return:
        """
        flows_count = 0
        for row in self.iterate('flows'):
            try:
                row: dict
                flow = {
                    'aid': row['aid'],
                    'label' : row['label']
                }
                
                if self.db.store_flow(flow, self.tool_name):
                    flows_count += 1
                    # used for printing the stats in the main.py
                    #TODO shouldn't be stored in a separate table!
                    self.db.store_flows_count(self.tool_name, flows_count)
            except Exception as e:
                try:
                    aid_causing_issues = flow.get('aid', '')
                except NameError:
                    aid_causing_issues = ""
                    
                self.log("Problem parsing 1 flow: ",
                         f"AID : {aid_causing_issues}. "
                         f"discarding it. {e}",
                         error=True)
    
    def print_number_of_alerts_slips_detected(self):
        """
        prints the number of alerts detected by slips from the alerts
        table
        """
        self.execute("SELECT COUNT(*) FROM alerts")
        alerts_number: int = self.fetchone()[0]
        self.log(
            f"Number of alerts found in Slips alerts table: ",
            alerts_number
            )
        
    def print_number_of_slips_mapped_malicious_timewindows(self):
        """
        prints the number of slips "malicious" timewindows as seen by the gt.
        so this number is the answer to the following questions
        to how many tws were the alerts in slips db mapped?
        :return:
        """
        count: int = self.db.get_timewindow_count_by_label(
            self.tool_name,
            "malicious"
            )
        self.log(f"Slips alerts were mapped to: ",
                 f"{count} GT timewindows")
        
    def parse(self):
        """
        reads the output db of slips with
        the labels and stores it in this tools' db
        :return: 0 if all good, 1 if an error occured
        """
        try:
            self.log("Using Slips Version: ", self.version)
            self.connect()
            # labeling flows
            self.parse_flow_by_flow_labels()
            self.print_stats()
            # labeling tws
            self.print_number_of_alerts_slips_detected()
            self.parse_alerts_table()
            self.print_number_of_slips_mapped_malicious_timewindows()
            os._exit(0)
        except Exception as e:
            self.log("An error occurred: ", e, error=True)
            self.log("",f"{traceback.format_exc()}", error=True)
            os._exit(1)